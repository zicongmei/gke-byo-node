#!/bin/bash

# ==============================================================================
# setup-worker.sh
#
# Description: Configures an Ubuntu machine to be a Kubernetes worker node.
#              This script is intended to be run with arguments generated by
#              the companion `generate-worker-args.sh` script. It now uses
#              a pre-approved client certificate for the kubelet, removing
#              the need for manual CSR approval on the control plane after setup.
#
# Usage: See the --help flag.
# ==============================================================================

set -euo pipefail

# --- Default values ---
NODE_NAME=""
API_SERVER_URL=""
CLUSTER_CA_CERT_BASE64=""
NODE_PRIVATE_KEY_BASE64=""
NODE_CLIENT_CERT_BASE64="" # New required argument
CLUSTER_DNS_IP="10.96.0.10"
VERSION="" # New required argument for Kubernetes version
CONTAINERD_VERSION="1.7.22" # Default value, can be overridden by argument
CNI_PLUGINS_VERSION="1.5.1" # Default value, can be overridden by argument (without 'v')

# --- Argument Parsing ---
print_usage() {
    echo "Usage: $0 --name <node-name> --api-url <k8s-api-url> --ca-cert-base64 <ca-cert> --node-private-key-base64 <node-key> --node-client-cert-base64 <node-cert> --cluster-dns-ip <dns-ip> --version <k8s-version> [--containerd-version <version>] [--cni-version <version>]"
}

while [[ "$#" -gt 0 ]]; do
    case $1 in
        --name) NODE_NAME="$2"; shift ;;
        --api-url) API_SERVER_URL="$2"; shift ;;
        --ca-cert-base64) CLUSTER_CA_CERT_BASE64="$2"; shift ;;
        --node-private-key-base64) NODE_PRIVATE_KEY_BASE64="$2"; shift ;;
        --node-client-cert-base64) NODE_CLIENT_CERT_BASE64="$2"; shift ;;
        --cluster-dns-ip) CLUSTER_DNS_IP="$2"; shift ;;
        --version) VERSION="$2"; shift ;; # Added version argument
        --containerd-version) CONTAINERD_VERSION="$2"; shift ;; # New argument
        --cni-version) CNI_PLUGINS_VERSION="$2"; shift ;; # New argument
        --help) print_usage; exit 0 ;;
        *) echo "Unknown parameter passed: $1"; print_usage; exit 1 ;;
    esac
    shift
done

if [ -z "$NODE_NAME" ] || \
   [ -z "$API_SERVER_URL" ] || \
   [ -z "$CLUSTER_CA_CERT_BASE64" ] || \
   [ -z "$NODE_PRIVATE_KEY_BASE64" ] || \
   [ -z "$NODE_CLIENT_CERT_BASE64" ] || \
   [ -z "$VERSION" ]; then # Added check for new argument
    echo "Error: Missing required arguments."
    print_usage
    exit 1
fi

# Sanitize input versions by removing leading 'v'
VERSION="${VERSION#v}"
CONTAINERD_VERSION="${CONTAINERD_VERSION#v}"
CNI_PLUGINS_VERSION="${CNI_PLUGINS_VERSION#v}"

echo "--- Starting Kubernetes Worker Node Setup for ${NODE_NAME} (K8s Version: ${VERSION}, Containerd: ${CONTAINERD_VERSION}, CNI: ${CNI_PLUGINS_VERSION}) ---"

# Determine architecture for containerd and CNI plugins
ARCH=$(dpkg --print-architecture)
if [ "$ARCH" == "amd64" ]; then
    ARCH="amd64"
elif [ "$ARCH" == "arm64" ]; then
    ARCH="arm64"
else
    echo "Error: Unsupported architecture: $ARCH. Expected amd64 or arm64."
    exit 1
fi

# --- Step 1: System Preparation ---
echo "--> [1/6] Preparing system: updating packages and disabling swap..."
# apt-get update >/dev/null
# # Add 'dialog' to ensure debconf frontends work correctly and avoid warnings
# apt-get install -y ca-certificates curl gpg apt-transport-https dialog >/dev/null
swapoff -a
sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
echo "  [✓] System prepared."

# --- Step 2: Install CNI Plugins ---
echo "--> [2/6] Installing CNI plugins..."
mkdir -p /opt/cni/bin
# CNI_PLUGINS_VERSION="v1.5.1" # Now dynamically set by argument or default
CNI_PLUGINS_URL="https://github.com/containernetworking/plugins/releases/download/v${CNI_PLUGINS_VERSION}/cni-plugins-linux-${ARCH}-v${CNI_PLUGINS_VERSION}.tgz"
curl -sL "${CNI_PLUGINS_URL}" -o cni-plugins.tgz
if [ ! -f cni-plugins.tgz ]; then
    echo "Error: Downloaded cni-plugins.tgz not found. Exiting."
    exit 1
fi
echo "  --> Extracting CNI plugins..."
tar -xvf cni-plugins.tgz -C /opt/cni/bin >/dev/null
rm cni-plugins.tgz
echo "  [✓] CNI plugins installed."

# --- Step 3: Install Container Runtime (containerd) ---
echo "--> [3/6] Installing containerd runtime..."

echo "  --> Downloading containerd for ${ARCH} (version ${CONTAINERD_VERSION})..."
# Use -sL for silent and follow redirects
curl -sL "https://github.com/containerd/containerd/releases/download/v${CONTAINERD_VERSION}/cri-containerd-${CONTAINERD_VERSION}-linux-${ARCH}.tar.gz" -o containerd.tar.gz
if [ ! -f containerd.tar.gz ]; then
    echo "Error: Downloaded containerd.tar.gz not found. Exiting."
    exit 1
fi

echo "  --> Extracting containerd..."
# This command typically extracts binaries to /usr/local/bin, configs to /etc/containerd, and service files to /etc/systemd/system
tar -xvf containerd.tar.gz -C / >/dev/null

# Clean up the downloaded tarball
rm containerd.tar.gz

echo "  --> Configuring containerd (ensuring systemd cgroup driver)..."
# Ensure /etc/containerd/config.toml exists (it usually does, but good to be safe)
if [ ! -f /etc/containerd/config.toml ]; then
    echo "  [W] /etc/containerd/config.toml not found after extraction. Generating default..."
    mkdir -p /etc/containerd
    containerd config default > /etc/containerd/config.toml
fi
# Ensure cgroup driver is set to systemd, which is required for K8s
sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml

# Reload systemd daemon to pick up new service files (if any)
systemctl daemon-reload

echo "  --> Enabling and starting containerd service..."
systemctl enable containerd
systemctl restart containerd
echo "  [✓] Containerd installed, configured, and service started."

# --- Step 4: Install Kubernetes Components ---
echo "--> [4/6] Installing kubelet and kubectl..."

echo "  --> Checking for and removing existing kubelet and kubectl binaries..."
if [ -f /usr/bin/kubelet ]; then
    echo "    [i] Found existing /usr/bin/kubelet. Removing..."
    rm -f /usr/bin/kubelet
fi
if [ -f /usr/bin/kubectl ]; then
    echo "    [i] Found existing /usr/bin/kubectl. Removing..."
    rm -f /usr/bin/kubectl
fi
echo "  [✓] Existing Kubernetes binaries removed (if present)."

# Download kubelet
KUBELET_DOWNLOAD_URL="https://dl.k8s.io/release/v${VERSION}/bin/linux/${ARCH}/kubelet"
echo "  --> Downloading kubelet from ${KUBELET_DOWNLOAD_URL}..."
if ! curl -sL "${KUBELET_DOWNLOAD_URL}" -o /usr/bin/kubelet; then # Download to /usr/bin to match ExecStart path
    echo "Error: Failed to download kubelet from ${KUBELET_DOWNLOAD_URL}. Exiting."
    exit 1
fi
chmod +x /usr/bin/kubelet

# Download kubectl
KUBECTL_DOWNLOAD_URL="https://dl.k8s.io/release/v${VERSION}/bin/linux/${ARCH}/kubectl"
echo "  --> Downloading kubectl from ${KUBECTL_DOWNLOAD_URL}..."
if ! curl -sL "${KUBECTL_DOWNLOAD_URL}" -o /usr/bin/kubectl; then # Download to /usr/bin
    echo "Error: Failed to download kubectl from ${KUBECTL_DOWNLOAD_URL}. Exiting."
    exit 1
fi
chmod +x /usr/bin/kubectl

echo "  [✓] Kubernetes components installed."

# --- Step 5: Configure Kubernetes Directories and Credentials ---
echo "--> [5/6] Placing credentials and kubeconfig files..."
mkdir -p /var/lib/kubelet /var/lib/kube-proxy /etc/kubernetes/pki

# Decode and place credentials
echo "${CLUSTER_CA_CERT_BASE64}" | base64 -d > /etc/kubernetes/pki/ca.crt
echo "${NODE_PRIVATE_KEY_BASE64}" | base64 -d > "/var/lib/kubelet/${NODE_NAME}.key"
echo "${NODE_CLIENT_CERT_BASE64}" | base64 -d > "/var/lib/kubelet/${NODE_NAME}.crt"
chmod 600 "/var/lib/kubelet/${NODE_NAME}.key"
chmod 644 "/var/lib/kubelet/${NODE_NAME}.crt" # Client cert can be readable by kubelet

# Create kubelet.kubeconfig
# The kubeconfig for kubelet will now contain the pre-signed client certificate and key.
kubectl config set-cluster k8s-manual --server="${API_SERVER_URL}" --certificate-authority=/etc/kubernetes/pki/ca.crt --kubeconfig=/var/lib/kubelet/kubeconfig --embed-certs=true >/dev/null
# Use both client certificate and client key directly
kubectl config set-credentials "system:node:${NODE_NAME}" --client-certificate="/var/lib/kubelet/${NODE_NAME}.crt" --client-key="/var/lib/kubelet/${NODE_NAME}.key" --kubeconfig=/var/lib/kubelet/kubeconfig --embed-certs=true >/dev/null
kubectl config set-context default --cluster=k8s-manual --user="system:node:${NODE_NAME}" --kubeconfig=/var/lib/kubelet/kubeconfig >/dev/null
kubectl config use-context default --kubeconfig=/var/lib/kubelet/kubeconfig >/dev/null

# Fix: Create /etc/kubernetes/bootstrap-kubelet.conf to satisfy stat check
# Since we are using pre-signed certs, the kubelet directly uses --kubeconfig=/var/lib/kubelet/kubeconfig.
# This file is copied for compatibility, as some tools or older kubelet setups might expect bootstrap-kubelet.conf to exist.
mkdir -p /etc/kubernetes
cp /var/lib/kubelet/kubeconfig /etc/kubernetes/bootstrap-kubelet.conf
echo "  [✓] Created /etc/kubernetes/bootstrap-kubelet.conf"


# Create kube-proxy.kubeconfig
# kube-proxy typically uses a service account token or its own bootstrap mechanism,
# so this part remains as is, assuming a token will be available or handled differently.
kubectl config set-cluster k8s-manual --server="${API_SERVER_URL}" --certificate-authority=/etc/kubernetes/pki/ca.crt --kubeconfig=/var/lib/kube-proxy/kubeconfig --embed-certs=true >/dev/null
kubectl config set-credentials kube-proxy --token="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token 2>/dev/null || echo 'dummy-token')" --kubeconfig=/var/lib/kube-proxy/kubeconfig >/dev/null
kubectl config set-context default --cluster=k8s-manual --user=kube-proxy --kubeconfig=/var/lib/kube-proxy/kubeconfig >/dev/null
kubectl config use-context default --kubeconfig=/var/lib/kube-proxy/kubeconfig >/dev/null

echo "  [✓] Credentials and kubeconfigs created."

# --- Step 6: Configure Kubelet Service ---
echo "--> [6/6] Creating kubelet configuration and systemd service..."

# Clean up any kubeadm-generated drop-ins for kubelet service.
# This prevents conflicting configurations like bootstrap-kubeconfig environment variables.
echo "  --> Removing existing kubelet service drop-in configurations..."
rm -rf /etc/systemd/system/kubelet.service.d/*
echo "  [✓] Cleaned up old kubelet service configurations."

echo "  --> Creating CNI network configuration..."
mkdir -p /etc/cni/net.d
cat > /etc/cni/net.d/10-containerd-net.conflist <<EOF
{
  "name": "k8s-pod-network",
  "cniVersion": "0.3.1",
  "plugins": [
    {
      "type": "ptp",
      "mtu": 1460,
      "ipam": {
        "type": "host-local",
        "subnet": "169.254.32.0/20",
        "routes": [
          {
            "dst": "0.0.0.0/0"
          }
        ]
      }
    },
    {
      "type": "portmap",
      "capabilities": {
        "portMappings": true
      }
    }
  ]
}
EOF
echo "  [✓] CNI network configuration created."

# Kubelet config file
cat > /var/lib/kubelet/config.yaml <<EOF
apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
cgroupDriver: "systemd"
authentication:
  anonymous:
    enabled: false
  webhook:
    enabled: true
  x509:
    clientCAFile: "/etc/kubernetes/pki/ca.crt"
authorization:
  mode: Webhook
clusterDNS:
  - "${CLUSTER_DNS_IP}"
clusterDomain: "cluster.local"
rotateCertificates: true # Keep this, as it's good for automatic certificate renewals later.
tlsCertFile: "/var/lib/kubelet/${NODE_NAME}.crt"
tlsPrivateKeyFile: "/var/lib/kubelet/${NODE_NAME}.key"
EOF

# Kubelet systemd service file
cat > /etc/systemd/system/kubelet.service <<EOF
[Unit]
Description=Kubernetes Kubelet
Documentation=https://github.com/kubernetes/kubernetes
After=containerd.service
Requires=containerd.service

[Service]
ExecStart=/usr/bin/kubelet \\
  --config=/var/lib/kubelet/config.yaml \\
  --kubeconfig=/var/lib/kubelet/kubeconfig \\
  --container-runtime-endpoint=unix:///var/run/containerd/containerd.sock \\
  --register-node=true \\
  --v=2
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

echo "  [✓] Kubelet service configured."

# --- Step 7: Start Services ---
echo "--> [7/7] Enabling and starting kubelet service..."
systemctl daemon-reload
systemctl enable kubelet
systemctl restart kubelet
echo "  [✓] Kubelet service started."
echo
echo "------------------------------------------------------------------------"
echo "  [SUCCESS] Worker node setup is complete."
echo "------------------------------------------------------------------------"
